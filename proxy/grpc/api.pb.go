// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package pbrpc is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	Empty
	Err
	ContainerID
	Container
	Containers
	Io
	ExecOptions
*/
package pbrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
	Auth string `protobuf:"bytes,1,opt,name=auth" json:"auth,omitempty"`
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Empty) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

type Err struct {
	Err string `protobuf:"bytes,1,opt,name=err" json:"err,omitempty"`
}

func (m *Err) Reset()                    { *m = Err{} }
func (m *Err) String() string            { return proto.CompactTextString(m) }
func (*Err) ProtoMessage()               {}
func (*Err) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Err) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

type ContainerID struct {
	Id   string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Auth string `protobuf:"bytes,2,opt,name=auth" json:"auth,omitempty"`
}

func (m *ContainerID) Reset()                    { *m = ContainerID{} }
func (m *ContainerID) String() string            { return proto.CompactTextString(m) }
func (*ContainerID) ProtoMessage()               {}
func (*ContainerID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ContainerID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerID) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

// Container instance
type Container struct {
	Id            string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name          string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Image         string   `protobuf:"bytes,3,opt,name=image" json:"image,omitempty"`
	Command       string   `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	State         string   `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
	Status        string   `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Ips           []string `protobuf:"bytes,7,rep,name=ips" json:"ips,omitempty"`
	Shell         string   `protobuf:"bytes,8,opt,name=shell" json:"shell,omitempty"`
	PodName       string   `protobuf:"bytes,9,opt,name=pod_name,json=podName" json:"pod_name,omitempty"`
	ContainerName string   `protobuf:"bytes,10,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	Namespace     string   `protobuf:"bytes,11,opt,name=namespace" json:"namespace,omitempty"`
	RunningNode   string   `protobuf:"bytes,12,opt,name=running_node,json=runningNode" json:"running_node,omitempty"`
	LocServer     string   `protobuf:"bytes,13,opt,name=loc_server,json=locServer" json:"loc_server,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Container) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Container) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Container) GetIps() []string {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *Container) GetShell() string {
	if m != nil {
		return m.Shell
	}
	return ""
}

func (m *Container) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *Container) GetContainerName() string {
	if m != nil {
		return m.ContainerName
	}
	return ""
}

func (m *Container) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Container) GetRunningNode() string {
	if m != nil {
		return m.RunningNode
	}
	return ""
}

func (m *Container) GetLocServer() string {
	if m != nil {
		return m.LocServer
	}
	return ""
}

type Containers struct {
	Cs []*Container `protobuf:"bytes,1,rep,name=cs" json:"cs,omitempty"`
}

func (m *Containers) Reset()                    { *m = Containers{} }
func (m *Containers) String() string            { return proto.CompactTextString(m) }
func (*Containers) ProtoMessage()               {}
func (*Containers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Containers) GetCs() []*Container {
	if m != nil {
		return m.Cs
	}
	return nil
}

type Io struct {
	In  []byte `protobuf:"bytes,1,opt,name=in,proto3" json:"in,omitempty"`
	Out []byte `protobuf:"bytes,2,opt,name=out,proto3" json:"out,omitempty"`
}

func (m *Io) Reset()                    { *m = Io{} }
func (m *Io) String() string            { return proto.CompactTextString(m) }
func (*Io) ProtoMessage()               {}
func (*Io) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Io) GetIn() []byte {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Io) GetOut() []byte {
	if m != nil {
		return m.Out
	}
	return nil
}

type ExecOptions struct {
	Cmd  *Io        `protobuf:"bytes,1,opt,name=cmd" json:"cmd,omitempty"`
	C    *Container `protobuf:"bytes,2,opt,name=c" json:"c,omitempty"`
	Err  string     `protobuf:"bytes,3,opt,name=err" json:"err,omitempty"`
	Auth string     `protobuf:"bytes,4,opt,name=auth" json:"auth,omitempty"`
}

func (m *ExecOptions) Reset()                    { *m = ExecOptions{} }
func (m *ExecOptions) String() string            { return proto.CompactTextString(m) }
func (*ExecOptions) ProtoMessage()               {}
func (*ExecOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ExecOptions) GetCmd() *Io {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *ExecOptions) GetC() *Container {
	if m != nil {
		return m.C
	}
	return nil
}

func (m *ExecOptions) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *ExecOptions) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "pbrpc.empty")
	proto.RegisterType((*Err)(nil), "pbrpc.err")
	proto.RegisterType((*ContainerID)(nil), "pbrpc.ContainerID")
	proto.RegisterType((*Container)(nil), "pbrpc.Container")
	proto.RegisterType((*Containers)(nil), "pbrpc.Containers")
	proto.RegisterType((*Io)(nil), "pbrpc.io")
	proto.RegisterType((*ExecOptions)(nil), "pbrpc.execOptions")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ContainerServer service

type ContainerServerClient interface {
	GetInfo(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Container, error)
	List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Containers, error)
	Start(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error)
	Stop(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error)
	Restart(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error)
	Exec(ctx context.Context, opts ...grpc.CallOption) (ContainerServer_ExecClient, error)
}

type containerServerClient struct {
	cc *grpc.ClientConn
}

func NewContainerServerClient(cc *grpc.ClientConn) ContainerServerClient {
	return &containerServerClient{cc}
}

func (c *containerServerClient) GetInfo(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Container, error) {
	out := new(Container)
	err := grpc.Invoke(ctx, "/pbrpc.containerServer/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServerClient) List(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Containers, error) {
	out := new(Containers)
	err := grpc.Invoke(ctx, "/pbrpc.containerServer/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServerClient) Start(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error) {
	out := new(Err)
	err := grpc.Invoke(ctx, "/pbrpc.containerServer/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServerClient) Stop(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error) {
	out := new(Err)
	err := grpc.Invoke(ctx, "/pbrpc.containerServer/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServerClient) Restart(ctx context.Context, in *ContainerID, opts ...grpc.CallOption) (*Err, error) {
	out := new(Err)
	err := grpc.Invoke(ctx, "/pbrpc.containerServer/Restart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerServerClient) Exec(ctx context.Context, opts ...grpc.CallOption) (ContainerServer_ExecClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ContainerServer_serviceDesc.Streams[0], c.cc, "/pbrpc.containerServer/Exec", opts...)
	if err != nil {
		return nil, err
	}
	x := &containerServerExecClient{stream}
	return x, nil
}

type ContainerServer_ExecClient interface {
	Send(*ExecOptions) error
	Recv() (*ExecOptions, error)
	grpc.ClientStream
}

type containerServerExecClient struct {
	grpc.ClientStream
}

func (x *containerServerExecClient) Send(m *ExecOptions) error {
	return x.ClientStream.SendMsg(m)
}

func (x *containerServerExecClient) Recv() (*ExecOptions, error) {
	m := new(ExecOptions)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ContainerServer service

type ContainerServerServer interface {
	GetInfo(context.Context, *ContainerID) (*Container, error)
	List(context.Context, *Empty) (*Containers, error)
	Start(context.Context, *ContainerID) (*Err, error)
	Stop(context.Context, *ContainerID) (*Err, error)
	Restart(context.Context, *ContainerID) (*Err, error)
	Exec(ContainerServer_ExecServer) error
}

func RegisterContainerServerServer(s *grpc.Server, srv ContainerServerServer) {
	s.RegisterService(&_ContainerServer_serviceDesc, srv)
}

func _ContainerServer_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServerServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbrpc.containerServer/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServerServer).GetInfo(ctx, req.(*ContainerID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerServer_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbrpc.containerServer/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServerServer).List(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerServer_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServerServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbrpc.containerServer/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServerServer).Start(ctx, req.(*ContainerID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerServer_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbrpc.containerServer/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServerServer).Stop(ctx, req.(*ContainerID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerServer_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerServerServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbrpc.containerServer/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerServerServer).Restart(ctx, req.(*ContainerID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerServer_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ContainerServerServer).Exec(&containerServerExecServer{stream})
}

type ContainerServer_ExecServer interface {
	Send(*ExecOptions) error
	Recv() (*ExecOptions, error)
	grpc.ServerStream
}

type containerServerExecServer struct {
	grpc.ServerStream
}

func (x *containerServerExecServer) Send(m *ExecOptions) error {
	return x.ServerStream.SendMsg(m)
}

func (x *containerServerExecServer) Recv() (*ExecOptions, error) {
	m := new(ExecOptions)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ContainerServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbrpc.containerServer",
	HandlerType: (*ContainerServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _ContainerServer_GetInfo_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ContainerServer_List_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _ContainerServer_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ContainerServer_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _ContainerServer_Restart_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _ContainerServer_Exec_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 487 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xed, 0x6a, 0x13, 0x41,
	0x14, 0xed, 0x7e, 0x24, 0xe9, 0xde, 0x4d, 0x6b, 0xbd, 0x88, 0x8e, 0xa9, 0x4a, 0x5c, 0x50, 0x22,
	0x42, 0xb0, 0xd1, 0x37, 0xb0, 0x22, 0x01, 0xa9, 0xb0, 0x79, 0x80, 0xb0, 0x9d, 0x1d, 0xdb, 0x81,
	0xec, 0xcc, 0x30, 0x33, 0x91, 0xfa, 0x44, 0x3e, 0x92, 0xaf, 0x23, 0x73, 0x77, 0xb3, 0x2d, 0x6d,
	0x7e, 0xf4, 0x57, 0xee, 0x3d, 0xf7, 0x9c, 0x33, 0x7b, 0x3f, 0x02, 0x59, 0x65, 0xe4, 0xdc, 0x58,
	0xed, 0x35, 0x0e, 0xcc, 0xa5, 0x35, 0xbc, 0x38, 0x85, 0x81, 0x68, 0x8c, 0xff, 0x83, 0x08, 0x69,
	0xb5, 0xf5, 0xd7, 0x2c, 0x9a, 0x46, 0xb3, 0xac, 0xa4, 0xb8, 0x78, 0x01, 0x89, 0xb0, 0x16, 0x4f,
	0xe8, 0xa7, 0xab, 0x84, 0xb0, 0x38, 0x83, 0xfc, 0xab, 0x56, 0xbe, 0x92, 0x4a, 0xd8, 0xe5, 0x39,
	0x1e, 0x43, 0x2c, 0xeb, 0xae, 0x1e, 0xcb, 0xba, 0xf7, 0x8a, 0xef, 0x78, 0xfd, 0x8b, 0x21, 0xeb,
	0x35, 0xfb, 0x14, 0xaa, 0x6a, 0xc4, 0x4e, 0x11, 0x62, 0x7c, 0x06, 0x03, 0xd9, 0x54, 0x57, 0x82,
	0x25, 0x04, 0xb6, 0x09, 0x32, 0x18, 0x71, 0xdd, 0x34, 0x95, 0xaa, 0x59, 0x4a, 0xf8, 0x2e, 0x0d,
	0x7c, 0xe7, 0x2b, 0x2f, 0xd8, 0xa0, 0xe5, 0x53, 0x82, 0xcf, 0x61, 0x18, 0x82, 0xad, 0x63, 0x43,
	0x82, 0xbb, 0x2c, 0x34, 0x25, 0x8d, 0x63, 0xa3, 0x69, 0x12, 0x9a, 0x92, 0xc6, 0x91, 0xfe, 0x5a,
	0x6c, 0x36, 0xec, 0xb0, 0xd3, 0x87, 0x04, 0x5f, 0xc2, 0xa1, 0xd1, 0xf5, 0x9a, 0xbe, 0x2e, 0x6b,
	0x1f, 0x34, 0xba, 0xbe, 0x08, 0x1f, 0xf8, 0x0e, 0x8e, 0xf9, 0xae, 0xa3, 0x96, 0x00, 0x44, 0x38,
	0xea, 0x51, 0xa2, 0xbd, 0x82, 0x2c, 0x14, 0x9d, 0xa9, 0xb8, 0x60, 0x39, 0x31, 0x6e, 0x01, 0x7c,
	0x0b, 0x63, 0xbb, 0x55, 0x4a, 0xaa, 0xab, 0xb5, 0xd2, 0xb5, 0x60, 0x63, 0x22, 0xe4, 0x1d, 0x76,
	0xa1, 0x6b, 0x81, 0xaf, 0x01, 0x36, 0x9a, 0xaf, 0x9d, 0xb0, 0xbf, 0x85, 0x65, 0x47, 0xad, 0xc3,
	0x46, 0xf3, 0x15, 0x01, 0xc5, 0x1c, 0xa0, 0x1f, 0xac, 0xc3, 0x29, 0xc4, 0xdc, 0xb1, 0x68, 0x9a,
	0xcc, 0xf2, 0xc5, 0xc9, 0x9c, 0x96, 0x3c, 0xef, 0xcb, 0x65, 0xcc, 0x5d, 0xf1, 0x1e, 0x62, 0xa9,
	0x69, 0x03, 0x8a, 0x36, 0x30, 0x2e, 0x63, 0xa9, 0xc2, 0x3c, 0xf4, 0xd6, 0xd3, 0x02, 0xc6, 0x65,
	0x08, 0x0b, 0x03, 0xb9, 0xb8, 0x11, 0xfc, 0xa7, 0xf1, 0x52, 0x2b, 0x87, 0xa7, 0x90, 0xf0, 0xa6,
	0xdd, 0x59, 0xbe, 0xc8, 0x3a, 0x67, 0xa9, 0xcb, 0x80, 0xe2, 0x1b, 0x88, 0x38, 0x69, 0xf7, 0x3d,
	0x1a, 0xf1, 0xdd, 0x09, 0x25, 0xfd, 0x09, 0xf5, 0x37, 0x92, 0xde, 0xde, 0xc8, 0xe2, 0x6f, 0x0c,
	0x4f, 0xfa, 0xd9, 0xb5, 0xdd, 0xe1, 0x19, 0x8c, 0xbe, 0x0b, 0xbf, 0x54, 0xbf, 0x34, 0xe2, 0x7d,
	0xe7, 0xe5, 0xf9, 0xe4, 0xc1, 0x6b, 0xc5, 0x01, 0x7e, 0x80, 0xf4, 0x87, 0x74, 0x1e, 0xc7, 0x5d,
	0x8d, 0x0e, 0x7c, 0xf2, 0xf4, 0x3e, 0xd3, 0x11, 0x75, 0xb0, 0xf2, 0x95, 0xf5, 0x7b, 0xbd, 0x61,
	0xa7, 0xb7, 0xc1, 0x75, 0x06, 0xe9, 0xca, 0x6b, 0xf3, 0x08, 0xe6, 0x47, 0x18, 0x95, 0xc2, 0x3d,
	0xd2, 0xf6, 0x0b, 0xa4, 0xdf, 0x6e, 0x04, 0xef, 0x99, 0x77, 0x46, 0x3e, 0xd9, 0x83, 0x15, 0x07,
	0xb3, 0xe8, 0x53, 0x74, 0x39, 0xa4, 0x3f, 0xf1, 0xe7, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb0,
	0x72, 0xd9, 0xe6, 0xd1, 0x03, 0x00, 0x00,
}
